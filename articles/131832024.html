<p>作者：戴嘉华</p>
<p>转载请注明出处并保留原文链接（ <a class="issue-link js-issue-link" data-error-text="Failed to load issue title" data-id="131832024" data-permission-text="Issue title is private" data-url="https://github.com/livoras/blog/issues/14" data-hovercard-type="issue" data-hovercard-url="/livoras/blog/issues/14/hovercard" href="https://github.com/livoras/blog/issues/14">#14</a> ）和作者信息。</p>
<h2>目录</h2>
<ul>
<li>
<ol>
<li>前言</li>
</ol>
</li>
<li>
<ol start="2">
<li>问题的提出</li>
</ol>
</li>
<li>
<ol start="3">
<li>模板引擎和 Virtual-DOM 结合 —— Virtual-Template</li>
</ol>
</li>
<li>
<ol start="4">
<li>Virtual-Template 的实现</li>
</ol>
<ul>
<li>4.1 编译原理相关</li>
<li>4.2 模版引擎的EBNF</li>
<li>4.3 词法分析</li>
<li>4.4 语法分析与抽象语法树</li>
<li>4.5 代码生成</li>
</ul>
</li>
<li>
<ol start="5">
<li>完整的 Virtual-Template</li>
</ol>
</li>
<li>
<ol start="6">
<li>结语</li>
</ol>
</li>
</ul>
<h2>1. 前言</h2>
<p>本文尝试构建一个 Web 前端模板引擎，并且把这个引擎和 Virtual-DOM 进行结合。把传统模板引擎编译成 HTML 字符串的方式改进为编译成 Virtual-DOM 的 render 函数，可以有效地结合模板引擎的便利性和 Virtual-DOM 的性能。类似 ReactJS 中的 JSX。</p>
<p>阅读本文需要一些关于 ReactJS 实现原理或者 Virtual-DOM 的相关知识，可以先阅读这篇博客：<a href="https://github.com/livoras/blog/issues/13" data-hovercard-type="issue" data-hovercard-url="/livoras/blog/issues/13/hovercard">深度剖析：如何实现一个 Virtual DOM 算法</a> ， 进行相关知识的了解。</p>
<p>同时还需要对编译原理相关知识有基本的了解，包括 EBNF，LL(1)，递归下降的方法等。</p>
<h2>2. 问题的提出</h2>
<p>本人在就职的公司维护一个比较朴素的系统，前端渲染有两种方式：</p>
<ol>
<li>后台直接根据模板和数据直接把页面吐到前端。</li>
<li>后台只吐数据，前端用前端模板引擎渲染数据，动态塞到页面。</li>
</ol>
<p>当数据状态变更的时候，前端用 jQuery 修改页面元素状态，或者把局部界面用模板引擎重新渲染一遍。当页面状态很多的时候，用 jQuery 代码中会就混杂着很多的 DOM 操作，编码复杂且不便于维护；而重新渲染虽然省事，但是会导致一些性能、焦点消失的问题（具体可以看这篇<a href="https://github.com/livoras/blog/issues/13" data-hovercard-type="issue" data-hovercard-url="/livoras/blog/issues/13/hovercard">博客介绍</a>）。</p>
<p>因为习惯了 MVVM 数据绑定的编码方式，对于用 jQuery 选择器修改 wordings 等细枝末节的劳力操作个人感觉不甚习惯。于是就构思能否在这种朴素的编码方式上做一些改进，解放双手，提升开发效率。其实只要加入数据状态 -&gt; 视图的 one-way data-binding 开发效率就会有较大的提升。</p>
<p>而这种已经在运作多年的多人维护系统，引入新的 MVVM 框架并不是一个非常好的选择，在兼容性和风险规避上大家都有诸多的考虑。于是就构思了一个方案，在前端模板引擎上做手脚。可以在几乎零学习成本的情况下，做到 one-way data-binding，大量减少 jQuery DOM 操作，提升开发效率。</p>
<h2>3. 模板引擎和 Virtual-DOM 结合 —— Virtual-Template</h2>
<p>考虑以下模板语法：</p>
<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">div</span>&gt;
  &lt;<span class="pl-ent">h1</span>&gt;{title}&lt;/<span class="pl-ent">h1</span>&gt;
  &lt;<span class="pl-ent">ul</span>&gt;
    {each users as user i}
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>user-item<span class="pl-pds">"</span></span>&gt;
      &lt;<span class="pl-ent">img</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>/avatars/{user.id}<span class="pl-pds">"</span></span> /&gt;
      &lt;<span class="pl-ent">span</span>&gt;NO.{i + 1} - {user.name}&lt;/<span class="pl-ent">span</span>&gt;
      {if user.isAdmin}
        I am admin
      {elseif user.isAuthor}
        I am author
      {else}
        I am nobody
      {/if}
    &lt;/<span class="pl-ent">li</span>&gt;
    {/each}
  &lt;/<span class="pl-ent">ul</span>&gt;
&lt;/<span class="pl-ent">div</span>&gt;</pre></div>
<p>这只一个普通的模板引擎语法（类似 artTemplate），支持循环语句（each）、条件语句（if elseif else ..）、和文本填充（{...}）， 应该比较容易看懂，这里就不解释。当用下面数据渲染该模板的时候：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> data <span class="pl-k">=</span> {
  title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Users List<span class="pl-pds">'</span></span>,
  users<span class="pl-k">:</span> [
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user0<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jerry<span class="pl-pds">'</span></span>, isAdmin<span class="pl-k">:</span> <span class="pl-c1">true</span>},
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user1<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Lucy<span class="pl-pds">'</span></span>, isAuthor<span class="pl-k">:</span> <span class="pl-c1">true</span>},
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user2<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tomy<span class="pl-pds">'</span></span>}
  ]
}</pre></div>
<p>会得到下面的 HTML 字符串：</p>
<div class="highlight highlight-text-html-basic"><pre>&lt;<span class="pl-ent">div</span>&gt;
  &lt;<span class="pl-ent">h1</span>&gt;Users List&lt;/<span class="pl-ent">h1</span>&gt;
  &lt;<span class="pl-ent">ul</span>&gt;
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>user-item<span class="pl-pds">"</span></span>&gt;
       &lt;<span class="pl-ent">img</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>/avatars/user0<span class="pl-pds">"</span></span> /&gt;
       &lt;<span class="pl-ent">span</span>&gt;NO.1 - Jerry&lt;/<span class="pl-ent">span</span>&gt;
       I am admin
    &lt;/<span class="pl-ent">li</span>&gt;
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>user-item<span class="pl-pds">"</span></span>&gt;
       &lt;<span class="pl-ent">img</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>/avatars/user1<span class="pl-pds">"</span></span> /&gt;
       &lt;<span class="pl-ent">span</span>&gt;NO.2 - Lucy&lt;/<span class="pl-ent">span</span>&gt;
       I am author
    &lt;/<span class="pl-ent">li</span>&gt;
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>user-item<span class="pl-pds">"</span></span>&gt;
       &lt;<span class="pl-ent">img</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>/avatars/user2<span class="pl-pds">"</span></span> /&gt;
       &lt;<span class="pl-ent">span</span>&gt;NO.3 - Tomy&lt;/<span class="pl-ent">span</span>&gt;
       I am nobody
    &lt;/<span class="pl-ent">li</span>&gt;
  &lt;/<span class="pl-ent">ul</span>&gt;
&lt;/<span class="pl-ent">div</span>&gt;</pre></div>
<p>把这个字符串塞入文档当中就可以生成 DOM 。但是问题是如果数据变更了，例如<code>data.title</code>由<code>Users List</code>修改成<code>Users</code>，你只能用 jQuery 修改 DOM 或者直接重新渲染一个新的字符串塞入文档当中。</p>
<p>然而我们可以参考 ReactJS 的 JSX 的做法，不把模板编译成 HTML， 而是把模板编译成一个返回 Virtual-DOM 的 render 函数。render 函数会根据传入的 state 不同返回不一样的 Virtual-DOM ，然后就可以根据 Virtual-DOM 算法进行 diff 和 patch：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c"><span class="pl-c">//</span> setup codes</span>
<span class="pl-c"><span class="pl-c">//</span> ...</span>

<span class="pl-k">var</span> render <span class="pl-k">=</span> <span class="pl-en">template</span>(tplString) <span class="pl-c"><span class="pl-c">//</span> template 把模板编译成 render 函数而不是 HTML 字符串</span>
<span class="pl-k">var</span> root1 <span class="pl-k">=</span> <span class="pl-en">render</span>(state1) <span class="pl-c"><span class="pl-c">//</span> 根据初始状态返回的 virtual-dom</span>

<span class="pl-k">var</span> dom <span class="pl-k">=</span> <span class="pl-smi">root</span>.<span class="pl-en">render</span>() <span class="pl-c"><span class="pl-c">//</span> 根据 virtual-dom 构建一个真正的 dom 元素</span>
<span class="pl-c1">document</span>.<span class="pl-c1">body</span>.<span class="pl-c1">appendChild</span>(dom)

<span class="pl-k">var</span> root2 <span class="pl-k">=</span> <span class="pl-en">render</span>(state2) <span class="pl-c"><span class="pl-c">//</span> 状态变更，重新渲染另外一个 virtual-dom</span>
<span class="pl-k">var</span> patches <span class="pl-k">=</span> <span class="pl-en">diff</span>(root1, root2) <span class="pl-c"><span class="pl-c">//</span> virtual-dom 的 diff 算法</span>
<span class="pl-en">patch</span>(dom, patches) <span class="pl-c"><span class="pl-c">//</span> 更新真正的 dom 元素</span></pre></div>
<p>这样做好处就是：既保留了原来模板引擎的语法，又结合了 Virtual-DOM 特性：当状态改变的时候不再需要 jQuery 了，而是跑一遍 Virtual-DOM 算法把真正的 DOM 给patch了，达到了 one-way data-binding 的效果，总结流程就是：</p>
<ol>
<li>先把模板编译成一个 render 函数，这个函数会根据数据状态返回 Virtual-DOM</li>
<li>用 render 函数构建 Virtual-DOM；并根据这个 Virtual-DOM 构建真正的 DOM 元素，塞入文档当中</li>
<li>当数据变更的时候，再用 render 函数渲染一个新的 Virtual-DOM</li>
<li>新旧的 Virtual-DOM 进行 diff，然后 patch 已经在文档中的 DOM 元素</li>
</ol>
<p>（恩，其实就是一个类似于 JSX 的东西）</p>
<p>这里重点就是，如何能把模板语法编译成一个能够返回 Virtual-DOM 的 render 函数？例如上面的模板引擎，不再返回 HTML 字符串了，而是返回一个像下面那样的 render 函数：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">render</span> (<span class="pl-smi">state</span>) {
  <span class="pl-k">return</span> <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>div<span class="pl-pds">'</span></span>, {}, [
    <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>h1<span class="pl-pds">'</span></span>, {}, [<span class="pl-smi">state</span>.<span class="pl-c1">title</span>]),
    <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>ul<span class="pl-pds">'</span></span>, {}, <span class="pl-smi">state</span>.<span class="pl-smi">users</span>.<span class="pl-en">map</span>(<span class="pl-k">function</span> (<span class="pl-smi">user</span>, <span class="pl-smi">i</span>) {
       <span class="pl-k">return</span> <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>li<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">"</span>class<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>user-item<span class="pl-pds">"</span></span>}, [
         <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>img<span class="pl-pds">'</span></span>, {<span class="pl-s"><span class="pl-pds">"</span>src<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>/avatars/<span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-smi">user</span>.<span class="pl-c1">id</span>}, []),
         <span class="pl-en">el</span>(<span class="pl-s"><span class="pl-pds">'</span>span<span class="pl-pds">'</span></span>, {}, [<span class="pl-s"><span class="pl-pds">'</span>No.<span class="pl-pds">'</span></span> <span class="pl-k">+</span> (i <span class="pl-k">+</span> <span class="pl-c1">1</span>) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span> - <span class="pl-pds">'</span></span> <span class="pl-k">+</span> <span class="pl-smi">user</span>.<span class="pl-c1">name</span>],
         (<span class="pl-smi">user</span>.<span class="pl-smi">isAdmin</span> 
           <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span>I am admin<span class="pl-pds">'</span></span>
           <span class="pl-k">:</span> <span class="pl-smi">uesr</span>.<span class="pl-smi">isAuthor</span> 
             <span class="pl-k">?</span> <span class="pl-s"><span class="pl-pds">'</span>I am author<span class="pl-pds">'</span></span>
             <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
       ])
    }))
  ])
}</pre></div>
<p>前面的模板和这个 render 函数在语义上是一样的，只要能够实现“模板 -&gt; render 函数”这个转换，就可以跑上面所说的 Virtual-DOM 的算法流程，这样就把模板引擎和 Virtual-DOM结合起来。为了方便起见，这里把这个结合体称为 Virtual-Template 。</p>
<h2>4. Virtual-Template 的实现</h2>
<p>网上关于模板引擎的实现原理介绍非常多。如果语法不是太复杂的话，可以直接通过对语法标签和代码片段进行分割，识别语法标签内的内容（循环、条件语句）然后拼装代码，具体可以参考<a href="http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html" rel="nofollow">这篇博客</a>。其实就是正则表达式使用和字符串的操作，不需要对语法标签以外的内容做识别。</p>
<p>但是对于和 HTML 语法已经差别较大的模板语法（例如 Jade ），单纯的正则和字符串操作已经不够用了，因为其语法标签以外的代码片段根本不是合法的 HTML 。这种情况下一般需要编译器相关知识发挥用途：模板引擎本质上就是把一种语言编译成另外一种语言。</p>
<p>而对于 Virtual-Template 的情况，虽然其除了语法标签以外的代码都是合法的 HTML 字符串，但是我们的目的是把它编译成返回 Virtual-DOM 的 render 函数，在构建 Virtual-DOM 的时候，你需要知道元素的 tagName、属性等信息，所以就需要对 HTML 元素本身做识别。</p>
<p>因此 Virtual-Template 也需要借助编译原理（编译器前端）相关的知识，把一种语言（模板语法）编译成另外一种语言（一个叫 render 的 JavaScript 函数）。</p>
<h3>4.1 编译原理相关</h3>
<p>CS 本科都教过编译原理，本文会用到编译器前端的一些概念。在实现模板到 render 函数的过程中，要经过几个步骤：</p>
<ol>
<li>词法分析：把输入的模板分割成词法单元（tokens stream）</li>
<li>语法分析：读入 tokens stream ，根据文法规则转化成抽象语法树（Abstract Syntax Tree）</li>
<li>代码生成：遍历 AST，生成 render 函数体代码</li>
</ol>
<p><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/livoras/blog/gh-pages/virtual-template/ast.png"><img src="https://raw.githubusercontent.com/livoras/blog/gh-pages/virtual-template/ast.png" alt="ast" style="max-width:100%;"></a></p>
<p>所以这个过程可以分成几个主要模块：tokenizer（词法分析器），parser（语法分析器），codegen（代码生成）。在此之前，还需要对模板的语法做文法定义，这是构建词法分析和语法分析的基础。</p>
<h3>4.2 模板引擎的 EBNF</h3>
<p>在计算机领域，对某种语言进行语法定义的时候，几乎都会用到 EBNF（扩展的巴科斯范式）。在定义模板引擎的语法的时候，也可以用到 EBNF。Virtual-Template 拥有非常简单的语法规则，支持上面所提到的 each、if 等语法：</p>
<pre><code>{each users as user i }
 &lt;div&gt; {user.name} &lt;/div&gt;
 ...
{/each}

{if user.isAdmin}
 ...
{elseif user.isAuthor}
 ...
{elseif user.isXXX}
 ...
{/if}
</code></pre>
<p>对于 <code>{user.name}</code> 这样的表达式插入，可以简单地看成是字符串，在代码生成的时候再做处理。这样我们的词法和语法分析就会简化很多，基本只需要对 each、if、HTML 元素进行处理。</p>
<p><strong>Virtual-Template 的 EBNF</strong>：</p>
<pre><code>Stat -&gt; Frag Stat | ε
Frag -&gt; IfStat | EachStat | Node | text

IfStat -&gt; '{if ...}' Stat {ElseIf} [Else] '{/if}'
ElseIf -&gt; '{elseif ...}' Stat
Else -&gt; '{else}' Stat|e

EachStat -&gt; '{each ...}' Stat '{/each}'

Node -&gt; OpenTag NodeTail
OpenTag -&gt; '/[\w\-\d]+/' {Attr}
NodeTail -&gt; '&gt;' Stat '/\&lt;[\w\d]+\&gt;/' | '/&gt;'

Attr -&gt; '/[\w\-\d]/+' Value
Value -&gt; '=' '/"[\s\S]+"/' | ε
</code></pre>
<p>可以把该文法转换成 LL(1) 文法，方便我们写递归下降的 parser。这个语法还是比较简单的，没有出现复杂的左递归情况。简单进行展开和提取左公因子消除冲突获得下面的 LL(1) 文法。</p>
<p><strong>LL(1) 文法：</strong></p>
<pre><code>Stat -&gt; Frag Stat | ε
Frag -&gt; IfStat | EachStat | Node | text

IfStat -&gt; '{if ...}' Stat ElseIfs Else '{/if}'
ElseIfs -&gt; ElseIf ElseIfs | ε
ElseIf -&gt; '{elseif ...}' Stat
Else -&gt; '{else}' Stat | ε

EachStat -&gt; '{each ...}' Stat '{/each}'

Node -&gt; OpenTag NodeTail
OpenTag -&gt; '/[\w\-\d]+/' Attrs
NodeTail -&gt; '&gt;' Stat '/\&lt;[\w\d]+\&gt;/' | '/&gt;'

Attrs -&gt; Attr Attrs | ε 
Attr -&gt; '/[\w\-\d]/+' Value
Value -&gt; '=' '/"[\s\S]+"/' | ε
</code></pre>
<h3>4.3 词法分析</h3>
<p>根据上面获得的 EBNF ，单引号包含的都是非终结符，可以知道有以下几种词法单元：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">module</span>.<span class="pl-smi">exports</span> <span class="pl-k">=</span> {
  <span class="pl-c1">TK_TEXT</span><span class="pl-k">:</span> <span class="pl-c1">1</span>, <span class="pl-c"><span class="pl-c">//</span> 文本节点</span>
  <span class="pl-c1">TK_IF</span><span class="pl-k">:</span> <span class="pl-c1">2</span>, <span class="pl-c"><span class="pl-c">//</span> {if ...}</span>
  <span class="pl-c1">TK_END_IF</span><span class="pl-k">:</span> <span class="pl-c1">3</span>, <span class="pl-c"><span class="pl-c">//</span> {/if}</span>
  <span class="pl-c1">TK_ELSE_IF</span><span class="pl-k">:</span> <span class="pl-c1">4</span>, <span class="pl-c"><span class="pl-c">//</span> {elseif ...}</span>
  <span class="pl-c1">TK_ELSE</span><span class="pl-k">:</span> <span class="pl-c1">5</span>, <span class="pl-c"><span class="pl-c">//</span> {else}</span>
  <span class="pl-c1">TK_EACH</span><span class="pl-k">:</span> <span class="pl-c1">6</span>, <span class="pl-c"><span class="pl-c">//</span> {each ...}</span>
  <span class="pl-c1">TK_END_EACH</span><span class="pl-k">:</span> <span class="pl-c1">7</span>, <span class="pl-c"><span class="pl-c">//</span> {/each}</span>
  <span class="pl-c1">TK_GT</span><span class="pl-k">:</span> <span class="pl-c1">8</span>, <span class="pl-c"><span class="pl-c">//</span> &gt;</span>
  <span class="pl-c1">TK_SLASH_GT</span><span class="pl-k">:</span> <span class="pl-c1">9</span>, <span class="pl-c"><span class="pl-c">//</span> /&gt;</span>
  <span class="pl-c1">TK_TAG_NAME</span><span class="pl-k">:</span> <span class="pl-c1">10</span>, <span class="pl-c"><span class="pl-c">//</span> &lt;div|&lt;span|&lt;img|...</span>
  <span class="pl-c1">TK_ATTR_NAME</span><span class="pl-k">:</span> <span class="pl-c1">11</span>, <span class="pl-c"><span class="pl-c">//</span> 属性名</span>
  <span class="pl-c1">TK_ATTR_EQUAL</span><span class="pl-k">:</span> <span class="pl-c1">12</span>, <span class="pl-c"><span class="pl-c">//</span> =</span>
  <span class="pl-c1">TK_ATTR_STRING</span><span class="pl-k">:</span> <span class="pl-c1">13</span>, <span class="pl-c"><span class="pl-c">//</span> "string"</span>
  <span class="pl-c1">TK_CLOSE_TAG</span><span class="pl-k">:</span> <span class="pl-c1">13</span>, <span class="pl-c"><span class="pl-c">//</span> &lt;/div&gt;|&lt;/span&gt;|&lt;/a&gt;|...</span>
  <span class="pl-c1">TK_EOF</span><span class="pl-k">:</span> <span class="pl-c1">100</span> <span class="pl-c"><span class="pl-c">//</span> end of file</span>
}</pre></div>
<p>使用 JavaScript 自带的正则表达式引擎编写 tokenizer 很方便，把输入的模板字符串从左到右进行扫描，按照上面的 token 的类型进行分割：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">Tokenizer</span> (<span class="pl-smi">input</span>) {
  <span class="pl-c1">this</span>.<span class="pl-c1">input</span> <span class="pl-k">=</span> input
  <span class="pl-c1">this</span>.<span class="pl-c1">index</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
  <span class="pl-c1">this</span>.<span class="pl-smi">eof</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
}

<span class="pl-k">var</span> pp <span class="pl-k">=</span> <span class="pl-smi">Tokenizer</span>.<span class="pl-c1">prototype</span>

<span class="pl-smi">pp</span>.<span class="pl-en">nextToken</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
  <span class="pl-c1">this</span>.<span class="pl-en">eatSpaces</span>()
  <span class="pl-k">return</span> (
    <span class="pl-c1">this</span>.<span class="pl-en">readCloseTag</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readTagName</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readAttrName</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readAttrEqual</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readAttrString</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readGT</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readSlashGT</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readIF</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readElseIf</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readElse</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readEndIf</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readEach</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readEndEach</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readText</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">readEOF</span>() <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">error</span>()
  )
}

<span class="pl-c"><span class="pl-c">//</span> read token methods</span>
<span class="pl-c"><span class="pl-c">//</span> ...</span></pre></div>
<p>Tokenizer 会存储一个 <code>index</code>，标记当前识别到哪个字符位置。每次调用 <code>nextToken</code> 会先跳过所有的空白字符，然后尝试某一种类型的 token ，识别失败就会尝试下一种，如果成功就直接返回，并且把 <code>index</code> 往前移；所有类型都试过都无法识别那么就是语法错误，直接抛出异常。</p>
<p>具体每个识别的函数其实就是正则表达式的使用，这里就不详细展开，有兴趣可以阅读源码 <a href="https://github.com/livoras/virtual-template/blob/dsl/src/tokenizer.js">tokenizer.js</a></p>
<p>最后会把这样的文章开头的模板例子转换成下面的 tokens stream：</p>
<div class="highlight highlight-source-js"><pre>{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>div<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">8</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>h1<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">8</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{title}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&lt;/h1&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>ul<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">8</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">6</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{each users as user i}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>li<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">11</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>class<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">12</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>=<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user-item<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">8</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>img<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">11</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>src<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">12</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>=<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>/avatars/{user.id}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">9</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>/&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">10</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>span<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">8</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>NO.<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{i + 1} - <span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{user.name}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&lt;/span&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">2</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{if user.isAdmin}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>I am admin<span class="pl-cce">\r\n</span>        <span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">4</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{elseif user.isAuthor}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>I am author<span class="pl-cce">\r\n</span>        <span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">5</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{else}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">1</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>I am nobody<span class="pl-cce">\r\n</span>        <span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">3</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{/if}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&lt;/li&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">7</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{/each}<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&lt;/ul&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">13</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>&lt;/div&gt;<span class="pl-pds">'</span></span> }
{ type<span class="pl-k">:</span> <span class="pl-c1">100</span>, label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>$<span class="pl-pds">'</span></span> }</pre></div>
<h3>4.4 语法分析与抽象语法树</h3>
<p>拿到 tokens 以后就可以就可以按顺序读取 token，根据模板的 LL(1) 文法进行语法分析。语法分析器，也就是 parser，一般可以采取<strong>递归下降</strong>的方式来进行编写。LL(1) 不允许语法中有冲突（ conflicts )，需要对文法中的产生式求解 FIRST 和 FOLLOW 集。</p>
<pre><code>FIRST(Stat) = {TK_IF, TK_EACH, TK_TAG_NAME, TK_TEXT}
FOLLOW(Stat) = {TK_ELSE_IF, TK_END_IF, TK_ELSE, TK_END_EACH, TK_CLOSE_TAG, TK_EOF}
FIRST(Frag) = {TK_IF, TK_EACH, TK_TAG_NAME, TK_TEXT}
FIRST(IfStat) = {TK_IF}
FIRST(ElseIfs) = {TK_ELSE_IF}
FOLLOW(ElseIfs) = {TK_ELSE, TK_ELSE}
FIRST(ElseIf) = {TK_ELSE_IF}
FIRST(Else) = {TK_ELSE}
FOLLOW(Else) = {TK_END_IF}
FIRST(EachStat) = {TK_EACH}
FIRST(OpenTag) = {TK_TAG_NAME}
FIRST(NodeTail) = {TK_GT, TK_SLASH_GT}
FIRST(Attrs) = {TK_ATTR_NAME}
FOLLOW(Attrs) = {TK_GT, TK_SLASH_GT}
FIRST(Value) = {TK_ATTR_EQUAL}
FOLLOW(Value) = {TK_ATTR_NAME, TK_GT, TK_SLASH_GT}
</code></pre>
<p>上面只求出了一些必要的 FIRST 和 FOLLOW 集，对于一些不需要预测的产生式就省略求解了。有了 FIRST 和 FOLLOW 集，剩下的编写递归下降的 parser 只是填空式的体力活。</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> Tokenizer <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./tokenizer<span class="pl-pds">'</span></span>)
<span class="pl-k">var</span> types <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./tokentypes<span class="pl-pds">'</span></span>)

<span class="pl-k">function</span> <span class="pl-en">Parser</span> (<span class="pl-smi">input</span>) {
  <span class="pl-c1">this</span>.<span class="pl-smi">tokens</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Tokenizer</span>(input)
  <span class="pl-c1">this</span>.<span class="pl-c1">parse</span>()
}

<span class="pl-k">var</span> pp <span class="pl-k">=</span> <span class="pl-smi">Parser</span>.<span class="pl-c1">prototype</span>

<span class="pl-smi">pp</span>.<span class="pl-en">is</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">type</span>) {
  <span class="pl-k">return</span> (<span class="pl-c1">this</span>.<span class="pl-smi">tokens</span>.<span class="pl-en">peekToken</span>().<span class="pl-c1">type</span> <span class="pl-k">===</span> type)
}

<span class="pl-smi">pp</span>.<span class="pl-en">parse</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
  <span class="pl-c1">this</span>.<span class="pl-smi">tokens</span>.<span class="pl-c1">index</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
  <span class="pl-c1">this</span>.<span class="pl-en">parseStat</span>()
  <span class="pl-c1">this</span>.<span class="pl-en">eat</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_EOF</span>)
}

<span class="pl-smi">pp</span>.<span class="pl-en">parseStat</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
  <span class="pl-k">if</span> (
    <span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_IF</span>) <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_EACH</span>) <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_TAG_NAME</span>) <span class="pl-k">||</span>
    <span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_TEXT</span>)
  ) {
    <span class="pl-c1">this</span>.<span class="pl-en">parseFrag</span>()
    <span class="pl-c1">this</span>.<span class="pl-en">parseStat</span>()
  } <span class="pl-k">else</span> {
    <span class="pl-c"><span class="pl-c">//</span> end</span>
  }
}

<span class="pl-smi">pp</span>.<span class="pl-en">parseFrag</span> <span class="pl-k">=</span> <span class="pl-k">function</span> () {
  <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_IF</span>)) <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-en">parseIfStat</span>()
  <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_EACH</span>)) <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-en">parseEachStat</span>()
  <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_TAG_NAME</span>)) <span class="pl-k">return</span> <span class="pl-c1">this</span>.<span class="pl-en">parseNode</span>()
  <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-c1">this</span>.<span class="pl-en">is</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_TEXT</span>)) {
    <span class="pl-k">var</span> token <span class="pl-k">=</span> <span class="pl-c1">this</span>.<span class="pl-en">eat</span>(<span class="pl-smi">types</span>.<span class="pl-c1">TK_TEXT</span>)
    <span class="pl-k">return</span> <span class="pl-smi">token</span>.<span class="pl-c1">label</span>
  } <span class="pl-k">else</span> {
    <span class="pl-c1">this</span>.<span class="pl-en">parseError</span>(<span class="pl-s"><span class="pl-pds">'</span>parseFrag<span class="pl-pds">'</span></span>)
  }
}

<span class="pl-c"><span class="pl-c">//</span> ...</span></pre></div>
<p>完整的 parser 可以查看 <a href="https://github.com/livoras/virtual-template/blob/dsl/src/parser.js">parser.js</a>。</p>
<h4>抽象语法树（Abstract Syntax Tree）</h4>
<p>递归下降进行语法分析的时候，可以同时构建模版语法的树状表示结构——抽象语法树，模板语法有以下的抽象语法树的节点类型：</p>
<pre><code>Stat: {
    type: 'Stat'
    members: [IfStat | EachStat | Node | text, ...]
}

IfStat: {
    type: 'IfStat'
    label: &lt;string&gt;,
    body: Stat
    elifs: [ElseIf, ...]
    elsebody: Stat
}

ElseIf: {
    type: 'ElseIf'
    label: &lt;string&gt;,
    body: Stat
}

EachStat: {
    type: 'EachStat'
    label: &lt;string&gt;,
    body: Stat
}

Node: {
    type: 'Node'
    name: &lt;string&gt;,
    attributes: &lt;object&gt;,
    body: Stat
}
</code></pre>
<p>因为 JavaScript 语法的灵活性，可以用字面量的 JavaScript 对象和数组直接表示语法树的树状结构。语法树构的建过程可以在语法分析阶段同时进行。最后，可以获取到如下图的语法树结构：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://raw.githubusercontent.com/livoras/blog/gh-pages/virtual-template/ast3.png"><img src="https://raw.githubusercontent.com/livoras/blog/gh-pages/virtual-template/ast3.png" alt="ast2" style="max-width:100%;"></a></p>
<p>完整的语法树构建过程，可以查看 <a href="https://github.com/livoras/virtual-template/blob/dsl/src/parser.js">parser.js</a> 。</p>
<p>从模版字符串到 tokens stream 再到 AST ，这个过程只需要对文本进行一次扫描，整个算法的时间复杂度为 O(n)。</p>
<p>至此，Virtual-Template 的编译器前端已经完成了。</p>
<h3>4.5 代码生成</h3>
<p>JavaScript 从字符串中构建一个新的函数可以直接用 <code>new Function</code> 即可。例如：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> newFunc <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Function</span>(<span class="pl-s"><span class="pl-pds">'</span>a<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>b<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>return a + b<span class="pl-pds">'</span></span>)
<span class="pl-en">newFunc</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> =&gt; 3</span></pre></div>
<p>这里需要通过语法树来还原 render 函数的函数体的内容，也就是 <code>new Function</code> 的第三个参数。</p>
<p>拿到模版语法的抽象语法树以后，生成相应的 JavaScript 函数代码就很好办了。只需要地对生成的 AST 进行深度优先遍历，遍历的同时维护一个数组，这个数组保存着 render 函数的每一行的代码：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">CodeGen</span> (<span class="pl-smi">ast</span>) {
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span> <span class="pl-k">=</span> []
  <span class="pl-c1">this</span>.<span class="pl-en">walk</span>(ast)
  <span class="pl-c1">this</span>.<span class="pl-c1">body</span> <span class="pl-k">=</span> <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">join</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-cce">\n</span><span class="pl-pds">'</span></span>)
}

<span class="pl-k">var</span> pp <span class="pl-k">=</span> <span class="pl-smi">CodeGen</span>.<span class="pl-c1">prototype</span>

<span class="pl-smi">pp</span>.<span class="pl-en">walk</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">node</span>) {
  <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-c1">type</span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>IfStat<span class="pl-pds">'</span></span>) {
    <span class="pl-c1">this</span>.<span class="pl-en">genIfStat</span>(node)
  } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-c1">type</span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>Stat<span class="pl-pds">'</span></span>) {
    <span class="pl-c1">this</span>.<span class="pl-en">genStat</span>(node)
  } <span class="pl-k">else</span> <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-c1">type</span> <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>EachStat<span class="pl-pds">'</span></span>) {
    <span class="pl-k">...</span>
  }
  <span class="pl-k">...</span>
}

<span class="pl-smi">pp</span>.<span class="pl-en">genIfStat</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">node</span>) {
  <span class="pl-k">var</span> expr <span class="pl-k">=</span> <span class="pl-smi">node</span>.<span class="pl-c1">label</span>.<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span>(<span class="pl-k">^</span><span class="pl-cce">\{</span><span class="pl-c1">\s</span><span class="pl-k">*</span>if<span class="pl-c1">\s</span><span class="pl-k">*</span>)<span class="pl-k">|</span>(<span class="pl-c1">\s</span><span class="pl-k">*</span><span class="pl-cce">\}</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>if (<span class="pl-pds">'</span></span> <span class="pl-k">+</span> expr <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>) {<span class="pl-pds">'</span></span>)
  <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-c1">body</span>) {
    <span class="pl-c1">this</span>.<span class="pl-en">walk</span>(<span class="pl-smi">node</span>.<span class="pl-c1">body</span>)
  }
  <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-smi">elseifs</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-c1">this</span>
    <span class="pl-smi">_</span>.<span class="pl-en">each</span>(<span class="pl-smi">node</span>.<span class="pl-smi">elseifs</span>, <span class="pl-k">function</span> (<span class="pl-smi">elseif</span>) {
      <span class="pl-smi">self</span>.<span class="pl-en">walk</span>(elseif)
    })
  }
  <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-smi">elsebody</span>) {
    <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(indent <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>} else {<span class="pl-pds">'</span></span>)
    <span class="pl-c1">this</span>.<span class="pl-en">walk</span>(<span class="pl-smi">node</span>.<span class="pl-smi">elsebody</span>)
  }
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> ...</span></pre></div>
<p><code>CodeGen</code> 类接受已经生成的 AST 的根节点，然后 <code>this.walk(ast)</code> 会对不同的节点类型进行解析。例如对于 <code>IfStat</code> 类型的节点：</p>
<div class="highlight highlight-source-js"><pre>{ 
  type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>IfStat<span class="pl-pds">'</span></span>,
  label<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>{if user.isAdmin}<span class="pl-pds">'</span></span>
  body<span class="pl-k">:</span> {<span class="pl-k">...</span>}
  elseifs<span class="pl-k">:</span> [{<span class="pl-k">...</span>}, {<span class="pl-k">...</span>}, {<span class="pl-k">...</span>}],
  elsebody<span class="pl-k">:</span> {<span class="pl-k">...</span>}
}</pre></div>
<p><code>genIfStat</code> 会把 <code>'{if user.isAdmin}'</code> 中的 <code>user.isAdmin</code> 抽离出来，然后拼接 JavaScript 的 if 语句，push 到 <code>this.lines</code> 中：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> expr <span class="pl-k">=</span> <span class="pl-smi">node</span>.<span class="pl-c1">label</span>.<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span>(<span class="pl-k">^</span><span class="pl-cce">\{</span><span class="pl-c1">\s</span><span class="pl-k">*</span>if<span class="pl-c1">\s</span><span class="pl-k">*</span>)<span class="pl-k">|</span>(<span class="pl-c1">\s</span><span class="pl-k">*</span><span class="pl-cce">\}</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
<span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>if (<span class="pl-pds">'</span></span> <span class="pl-k">+</span> expr <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>) {<span class="pl-pds">'</span></span>)</pre></div>
<p>然后会递归的对 <code>elseifs</code> 和 <code>elsebody</code> 进行遍历和解析，最后给 <code>if</code> 语句补上 <code>}</code>。所以如果 <code>elseifs</code> 和 <code>elsebody</code> 都不存在，<code>this.lines</code> 上就会有：</p>
<div class="highlight highlight-source-js"><pre>[<span class="pl-s"><span class="pl-pds">'</span>if (user.isAdmin) {<span class="pl-pds">'</span></span>, <span class="pl-k">&lt;</span>body<span class="pl-k">&gt;</span>, <span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span>]</pre></div>
<p>其它的结构和 <code>IfStat</code> 同理的解析和拼接方式，例如 <code>EachStat</code>:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pp</span>.<span class="pl-en">genEachStat</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">node</span>) {
  <span class="pl-k">var</span> expr <span class="pl-k">=</span> <span class="pl-smi">node</span>.<span class="pl-c1">label</span>.<span class="pl-c1">replace</span>(<span class="pl-sr"><span class="pl-pds">/</span>(<span class="pl-k">^</span><span class="pl-cce">\{</span><span class="pl-c1">\s</span><span class="pl-k">*</span>each<span class="pl-c1">\s</span><span class="pl-k">*</span>)<span class="pl-k">|</span>(<span class="pl-c1">\s</span><span class="pl-k">*</span><span class="pl-cce">\}</span><span class="pl-k">$</span>)<span class="pl-pds">/</span>g</span>, <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>)
  <span class="pl-k">var</span> tokens <span class="pl-k">=</span> <span class="pl-smi">expr</span>.<span class="pl-c1">split</span>(<span class="pl-sr"><span class="pl-pds">/</span><span class="pl-c1">\s</span><span class="pl-k">+</span><span class="pl-pds">/</span></span>)
  <span class="pl-k">var</span> list <span class="pl-k">=</span> tokens[<span class="pl-c1">0</span>]
  <span class="pl-k">var</span> item <span class="pl-k">=</span> tokens[<span class="pl-c1">2</span>]
  <span class="pl-k">var</span> key <span class="pl-k">=</span> tokens[<span class="pl-c1">3</span>]
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(
    <span class="pl-s"><span class="pl-pds">'</span>for (var <span class="pl-pds">'</span></span> <span class="pl-k">+</span> key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span> = 0, len = <span class="pl-pds">'</span></span> <span class="pl-k">+</span> list <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>.length; <span class="pl-pds">'</span></span> <span class="pl-k">+</span> key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span> &lt; len; <span class="pl-pds">'</span></span> <span class="pl-k">+</span> key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>++) {<span class="pl-pds">'</span></span>
  )
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>var <span class="pl-pds">'</span></span> <span class="pl-k">+</span> item <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span> = <span class="pl-pds">'</span></span> <span class="pl-k">+</span> list <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>[<span class="pl-pds">'</span></span> <span class="pl-k">+</span> key <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>];<span class="pl-pds">'</span></span>)
  <span class="pl-k">if</span> (<span class="pl-smi">node</span>.<span class="pl-c1">body</span>) {
    <span class="pl-c1">this</span>.<span class="pl-en">walk</span>(<span class="pl-smi">node</span>.<span class="pl-c1">body</span>)
  }
  <span class="pl-c1">this</span>.<span class="pl-smi">lines</span>.<span class="pl-c1">push</span>(<span class="pl-s"><span class="pl-pds">'</span>}<span class="pl-pds">'</span></span>)
}</pre></div>
<p>最后递归构造完成以后，<code>this.lines.join('\n')</code> 就把整个函数的体构建起来：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">if</span> (<span class="pl-smi">user</span>.<span class="pl-smi">isAdmin</span>) {
<span class="pl-k">...</span>
}

<span class="pl-k">for</span> (<span class="pl-k">var</span> <span class="pl-k">...</span>) {
<span class="pl-k">...</span>
}</pre></div>
<p>这时候 render 函数的函数体就有了，直接通过 <code>new Function</code> 构建 render 函数：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> code <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CodeGen</span>(ast)
<span class="pl-k">var</span> render <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Function</span>(<span class="pl-s"><span class="pl-pds">'</span>el<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>data<span class="pl-pds">'</span></span>, <span class="pl-smi">code</span>.<span class="pl-c1">body</span>)</pre></div>
<p><code>el</code> 是需要注入的构建 Virtual-DOM 的构建函数，<code>data</code> 需要渲染的数据状态：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> svd <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>simple-virtual-dom<span class="pl-pds">'</span></span>)
<span class="pl-k">var</span> root <span class="pl-k">=</span> <span class="pl-en">render</span>(<span class="pl-smi">svd</span>.<span class="pl-smi">el</span>, {users<span class="pl-k">:</span> [{isAdmin<span class="pl-k">:</span> <span class="pl-c1">true</span>}]})</pre></div>
<p>从模版 -&gt; Virtual-DOM 的 render 函数 -&gt; Virtual-DOM 的过程就完成了。完整的代码生成的过程可以参考：<a href="https://github.com/livoras/virtual-template/blob/dsl/src/codegen.js">codegen.js</a></p>
<h2>5. 完整的 Virtual-Template</h2>
<p>其实拿到 render 函数以后，每次手动进行 diff 和 patch 都是重复操作。可以把 diff 和 patch 也封装起来，只暴露一个 <code>setData</code> 的 API 。每次数据变更的时候，只需要 <code>setData</code> 就可以更新到 DOM 元素上（就像 ReactJS 的 <code>setState</code>）：</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c"><span class="pl-c">//</span> vTemplate.compile 编译模版字符串，返回一个函数</span>
<span class="pl-k">var</span> usersListTpl <span class="pl-k">=</span> <span class="pl-smi">vTemplate</span>.<span class="pl-c1">compile</span>(tplStr)

<span class="pl-c"><span class="pl-c">//</span> userListTpl 传入初始数据状态，返回一个实例</span>
<span class="pl-k">var</span> usersList <span class="pl-k">=</span> <span class="pl-en">usersListTpl</span>({
  title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Users List<span class="pl-pds">'</span></span>,
  users<span class="pl-k">:</span> [
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user0<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Jerry<span class="pl-pds">'</span></span>, isAdmin<span class="pl-k">:</span> <span class="pl-c1">true</span>},
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user1<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Lucy<span class="pl-pds">'</span></span>, isAuthor<span class="pl-k">:</span> <span class="pl-c1">true</span>},
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user2<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tomy<span class="pl-pds">'</span></span>}
  ]
})

<span class="pl-c"><span class="pl-c">//</span> 返回的实例有 dom 元素和一个 setData 的 API</span>
<span class="pl-c1">document</span>.<span class="pl-c1">appendChild</span>(<span class="pl-smi">usersList</span>.<span class="pl-smi">dom</span>)

<span class="pl-c"><span class="pl-c">//</span> 需要变更数据的时候，setData 一下即可</span>
<span class="pl-smi">usersList</span>.<span class="pl-en">setData</span>({
  title<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Users<span class="pl-pds">'</span></span>,
  users<span class="pl-k">:</span> [
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user1<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Lucy<span class="pl-pds">'</span></span>, isAuthor<span class="pl-k">:</span> <span class="pl-c1">true</span>},
    {id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>user2<span class="pl-pds">'</span></span>, name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Tomy<span class="pl-pds">'</span></span>}
  ]
})</pre></div>
<p>完整的 Virtual-Template 源码托管在 <a href="https://github.com/livoras/virtual-template">github</a> 。</p>
<h2>6. 结语</h2>
<p>这个过程其实和 ReactJS 的 JSX 差不多。就拿 Babel 的 JSX 语法实现而言，它的 parser 叫 <a href="https://github.com/babel/babel/tree/master/packages/babylon">babylon</a>。而 babylon 基于一个叫 <a href="https://github.com/marijnh/acorn">acorn</a> 的 JavaScript 编写的 JavaScript 解释器和它的 JSX 插件 <a href="https://github.com/RReverser/acorn-jsx">acorn-jsx</a>。其实就是利用 acorn 把文本分割成 tokens，而 JSX 语法分析部分由 acorn-jsx 完成。</p>
<p>Virtual-Template 还不能应用于实际的生产环境，需要完善的东西还有很多。本文记录基本的分析和实现的过程，也有助于更好地理解和学习 ReactJS 的实现。</p>
<p>（全文完）</p>