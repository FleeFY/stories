C++也算是有个把月了, 最近复习了一下C++中的类内各种合成函数, 这里做个总结. 既是帮助别人的同时也是帮助我自己, 便于日后复习, 如果有任何错误欢迎提出.



### 各种类内合成函数

编译器在某些条件下会帮忙合成如下几个函数, 分别是默认构造函数, 拷贝构造函数,移动构造函数, 拷贝赋值运算符, 移动赋值运算符和析构函数.



#### 合成的默认构造函数 :

1 . 它对于类内的成员变量是这样处理的 : 
   - 对于基础类型, 比如`char`, `int`, 还有C语言数组例如`int [10]`之流, 结果是未定义的, 原因是为了兼容C语言.
   - 对于类类型, 调用其默认构造函数进行初始化.(当然, 如果类内的某个成员类不存在默认构造函数的话, 编译器不会为该类合成默认构造函数.)

2 . 另一方面, **一旦用户手动实现了任何一个构造函数, 记住是任何一个, 那么编译器是不会主动再合成默认构造函数的**, 当然你可以使用 `T() = default;` 来显式地告诉编译器为你合成默认构造函数. 

如下几种情况合成的默认构造函数可能是删除的 :

1. 如果类内某个成员的默认构造函数是私有的或者删除的.
2. 如果类内含义const成员, 且该成员没有默认值.
3. 如果类内含有引用成员.
4. 如果类内某个成员的析构函数是私有的或者删除的.



#### 合成的拷贝构造函数 :

1 . 它对于类内的成员变量是这样处理的 : 
   - 对于基础类型, 它使用直接拷贝的方式. 所以如果你的类中有指针指向了手动分配的资源, 那么你就要注意了, **因为一旦进行拷贝, 那么改份资源将被这两个类共享**.
   - 对于类类型, 它调用其相应的拷贝构造函数.

2 . 另外一方面, **只要用户不手动实现拷贝构造函数, 编译器都会自动合成一个拷贝构造函数, 这一点和默认构造函数不一样.**

如下几种情况合成的拷贝构造函数可能是删除的 :

1. 如果类内某个成员的拷贝构造函数是私有的或者删除的.
2. 如果类内某个成员的析构函数是私有的或者删除的.
3. 手动定义了移动操作(构造和运算符都行)



#### 合成的拷贝赋值运算符 :

它的行为和合成的拷贝构造函数基本相同, 并且同样也是只要不手动实现就会被自动合成.

如下几种情况合成的拷贝复制运算符可能是删除的 :

1. 如果类内某个成员的拷贝赋值运算符是私有的或者删除的.
2. 如果类内含义const成员.
3. 如果类内含有引用成员.
4. 手动定义了移动操作(构造和运算符都行)



#### 合成的析构函数 :

1. 合成析构函数一般为空.
2. 对象的销毁在析构函数的函数体之后执行.
3. 当类中某个成员的析构函数是删除的或者私有的, 则该析构函数是删除的.



#### 合成的移动操作

1 . 它对于类内的成员变量是这样处理的 : 

   - 对于基础类型, 它使用直接拷贝的方式. 所以如果你的类中有指针指向了手动分配的资源, 那么该份资源直接被移动到目标对象, 源对象中指针指向0.
   - 对于类类型, 调用相应的移动操作.


如下几种情况编译器<u>**会为**</u>类生产移动构造函数的, 此时所有可能使用移动操作的情形用拷贝操作替代 :

1. 一个类没有定义任何自己版本的拷贝构造函数, 拷贝赋值运算符或者析构函数.
2. 类中有任何一个非static的数据成员都能移动.

2 . 另一方面, **移动操作永远不会被隐式定义为删除的函数**, 除非我们显式要求编译器生成(`=defaulat`), 但类中却存在着不能移动的非static成员时, 移动操作将被定义为delete.

如下几种情况会导致类无法移动所有非static成员 :

1. 类中某个成员定义了自己的拷贝操作, 且未定义移动操作(此时移动操作并不会自动合成).
2. 类中某个成员不存在移动操作是删除的或者私有的.
3. 析构函数是删除的或者私有的(此时仅仅移动构造函数不能用)
4. 类中存在const或者引用的成员

## 这些函数的调用时机

### 默认构造函数

1. 显式构造
```c++
T x; // default constructor
T x(); // error, it's function declaration.
T x{}; // default constructor
```
2. 另外在类中作为成员的时候, 如果构造函数中并没有涉及到该成员, 则也将执行默认构造函数.


### 拷贝构造函数

1.
```c++
T y;
T x(y) ;
```

2.
```c++
T x = y;
```

3 . 这种情况需要提一下, 表面上这种情况调用的是`T(int)`, 但实际上这里涉及到一种编译器的优化方式叫做**Copy elision**, 关于优化我在[这里](https://github.com/nzhl/blog/tree/master/category/cpp/谈谈RVO%2C%20NRVO%2C%20std::move)做了一些的介绍, 在不优化的情况下, 下面的式子首先调用T(3)获得临时变量然后才是T x(临时变量)完成初始化, 但是编译器优化之后, 为了减少不必要的拷贝, 这里直接被优化成了T x(3),  所以所表现出来的效果就是只调用了`T x(int)`.
```c++
T x = 3; // image there is a constructor T(int);
```

下面是对于证明上面的结论的证明

```c++
#include <iostream>

class X{
public:
    X(){
        std::cout << "default" << std::endl;
    }
    X(const X& test){
        std::cout << "copy" << std::endl;
    }

    X(int x){
        std::cout << "int" << std::endl;
    }

};

int main(){
    X x = 3;
}

```

此时输出结果为 `int`, 然后此时修改代码为如下 :

```c++
#include <iostream>

class X{
public:
    X(){
        std::cout << "default" << std::endl;
    }

    X(int x){
        std::cout << "int" << std::endl;
    }
private:
    X(const X& test){
        std::cout << "copy" << std::endl;
    }

};

int main(){
    X x = 3;
}

```

结果编译器报错 :

```bash
main.cpp:30:7: error: calling a private constructor of class 'X'
    X x = 3;
      ^
main.cpp:19:5: note: declared private here
    X(const X& test){
    ^
1 error generated.

```

也就是说, 该编译器优化**只有在拷贝构造函数可访问的前提下才能进行**.

4 . 传递参数

```c++
T x;
xxx(x); // function xxx must have a parameter which is T type (not reference).

```

5 . 传递返回值

```c++
T x = xxx() // function xxx must have a return type T
```

这种情况也不一定能看到, 而且多数情况下这里会调用移动构造函数而不是拷贝构造函数.
下面是证明 :

```c++
#include <iostream>

class X{
public:
    X(){
        std::cout << "default" << std::endl;
    }


    X(int x){
        std::cout << "int" << std::endl;
    }
//private:
    X(const X& test){
        std::cout << "copy" << std::endl;
    }

    X(const X&& test){
        std::cout << "move" << std::endl;
    }
};

X xxx(){
    X n;
    return n;
}

int main(){
    xxx();
}

```

此时函数结果为`default`. 但如果将`private`前面的注释去掉, 将会报错 :

```bash
main.cpp:25:12: error: calling a private constructor of class 'X'
    return n;
           ^
main.cpp:18:5: note: declared private here
    X(const X&& test){
    ^
1 error generated.
```
此时再注释掉移动构造函数, 报错如下 :
```bash
main.cpp:27:12: error: calling a private constructor of class 'X'
    return n;
           ^
main.cpp:14:5: note: declared private here
    X(const X& test){
    ^
1 error generated.
```

我们可以暂时不管为什么这里优先调用移动构造函数, 但是我们可以明确的是, 如果没有移动构造函数的情况下, 这里虽然优化的结果是只是用了默认构造函数, 但是如果不考虑优化这里确实会调用拷贝构造函数, 其实这里的优化也属于`copy elision and return value optimization`.
最后列表初始化数组中的元素或者聚合类的成员时, 也会用到拷贝构造函数, 这里就不提了.


### 移动构造函数
这里说实话我自己也不是很清楚, 反正很多要用到临时量, 右值的情况都会调用, 但是考虑编译器优化的话, 很多时候**即使按照规则本来应该调用**, 我们也无法看到. 比如这种情况 :
```c++
T x{T{}}
```
这里其实对于编译器而言等价于`T x{}`或者 就是`T x;` 这里使用了一种叫做构造函数消除的优化, 所以根本看不出来. 另外这里有一点值得一提的是我为什么没有写成 `T x(T());` 这就是C++的众多坑之一`most vexing parse`, 如果你这么写了其实编译器会认为这是一个返回类型为T 接受一个返回类型为T参数列表为空的函数指针的函数. 对于编译器来讲, 如果在参数列表中出现函数调用, 将直接转化为该函数的指针, 也就是里的 `T()` 其实是一个返回T接受0个参数的函数指针, 这其实类似于你在参数列表中写`int[]`相当于`int *`. 类似的情况, 同时也更加难以察觉的还有`T(T())`, 这也是一个函数声明, 但是我至今不知道这声明的是什么. 具体可以看这个 [帖子](https://www.zhihu.com/question/49879096?from=profile_question_card), 也是我问的问题.

我个人觉得比较复杂的地方差不多就这么多了额.
